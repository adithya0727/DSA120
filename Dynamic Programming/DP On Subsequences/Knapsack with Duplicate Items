/* Approach :
Given a set of N items, each with a weight and a value, represented by the array w and val respectively. Also, a knapsack with weight limit W.
The task is to fill the knapsack in such a way that we can get the maximum profit. Return the maximum profit.
Note: Each item can be taken any number of times.

1) Memoization : Similarly using pick and non-pick method + Infinite Pattern.
TC : O(N*W)     SC : O(N*W) + O(N)   
2) Tabulation : Reverse of Memoization Traversal
TC : O(N*W)     SC : O(N*W)  
3) Space Optimization : use only 2 seperate vectors.
TC : O(N*W)     SC : O(W)  
4) 2nd level optimization : 1 Array Optimization.
TC : O(N*W)     SC : O(W)  
*/

1) private:
        int cal(int n,int W,int val[],int wt[],vector<vector<int>>&dp){
            if(W == 0)  return 0;
            if(n == 0){
                if(W >= wt[0]){
                    return (W/wt[0])*val[0]; 
                }
                else
                    return 0;
            }
            if(dp[n][W] != -1)  return dp[n][W];
            int notpick = cal(n-1,W,val,wt,dp);
            int pick = 0;
            if(W >= wt[n])  pick = val[n] + cal(n,W-wt[n],val,wt,dp);
            return dp[n][W] = max(notpick,pick);
        }
    
    
public:
    int knapSack(int N, int W, int val[], int wt[])
    {
        vector<vector<int>>dp(N,vector<int>(W+1,-1));
        return cal(N-1,W,val,wt,dp);
    }
