/* Approach:
Given an undirected graph with V vertices labelled from 0 to V-1 and E edges, check whether it contains any cycle or not.
Graph is in the form of adjacency list where adj[i] contains all the nodes ith node is having edge with.
1) [BFS] : 
INTUITION : By using bfs , we travel two different paths by travelling neighbours : we keep track of the parent too so that we don't consider that as re-visiting a node.
If in any case , there's a repetition : it means there's a cycle , why? : because since we start travelling along two different paths : except the parent there
shouldn't really be a re-visited node and if someone has already visited that it means there's an intersection point which creates a CYCLE.
time -  O(V+2E) //Regular bfs complexity.
space - O(V)

2) [DFS] :
INTUITION : 
time -  
space - 
*/

1) bool bfs(vector<int> adj[],int start,vector<bool>&visited){        [BFS]
        queue<pair<int,int>>q;
        q.push({start,-1});    //regular bfs
        visited[start] = true;
        while(!q.empty()){
            int idx = q.front().first;
            int parent = q.front().second;
            q.pop();
            for(auto &neighbour : adj[idx]){    //for each vector(containing connecting edges) : in that particular adj[idx] , we check for its neighbours by traversing it. 
                if(visited[neighbour] && neighbour !=parent){    //if that node has already been visited by someone and it's not a PARENT , this is our 
                    return true;        //intersection point.
                }
                if(!visited[neighbour]){    //regular bfs , if it hasn't been visited yet , then just push it into the queue and make it visited.
                    q.push({neighbour,idx});    //this CONDITION IS ALWAYS THE PARENT'S RE-VISITING CASE , ACTUALLY THIS SNIPPENT CAN BE FULLY ALSO REPLACED WITH
                    visited[neighbour] = true;    //just checking for the parent and the code will work just fine : if(neighbour != parent).
                }
            }
        }
        return false;
    }
  
  
    // Function to detect cycle in an undirected graph.
    bool isCycle(int V, vector<int> adj[]) {
        vector<bool>visited(V,false);
        for(int i=0;i<V;i++){    //to check for disconnected graphs too.
            if(!visited[i]){
                if(bfs(adj,i,visited))
                    return true;
            }
        }
        return false;
    }
