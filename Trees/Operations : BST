/* Approach:

1) Search a Node : So , we going to search a tree based on a correct path using the bst property : if root->data > data then move left otherwise move right and we follow
along a correct path : if the data exists it should exist in this particular path only , we don't have to perform dfs or bfs to check if that data exists anywhere else,
because this is a sorted tree and we are performing binary search. If exists , we keep RECURSIVELY RETURINING THE VALUE OF THAT NODE OR if it doesnt exist we keep recursively returning NULL.
we don't have to look or further perform any operations , we just have to return it.
time - O(H) space - O(H)
2) Insert a Node : we cannot regularly add data from the root like we did in BT. Here , we perform the following:(once we have confirmed that the data doesn't exist in the tree)
we again move along a correct particular path using the bst property till we reach NULL : once we've reached NULL , it means we've found a empty spot where the 
Node->val correctly sits , so then we create a new node in heap with the given data and return it to the previous stack frame where we perform the ATTACHING operation
and [V.IMP] : RETURN THE UPDATED NODE. the prev stack frame node , now has a new left or right pointer based on the node value and we return that modified node to the prev
and so on till we reach the head. so we ultimately return the updated head , which has the last new leaf value being added/attached to the end.
time - O(H) space - O(H)
3) Ceil of a BST : Smallest root->val that is Greater than or Equal to KEY.
base case : if we do not find any node->val greater than or equal to key , we return null along as we reach the PATH'S end : remember this is BST : there is only one 
correct path we move towards , so if along that path we find nothing and reach null : it means it doesn't exist in the tree as per BST PROPERTY.
we kep track of the minimum value of ceil : all node->val's that are GREATER THAN KEY ARE POSSIBLE CANDIDATES FOR AN ANSWER , minimum of those is the answer.()node->val == key : minimum value.
time and space - O(H)
4) Floor of a BST : Greatest root->val that is LESSER THAN OR EQUAL TO KEY.
same as ceil , all the root->val lesser than key values are candidates and among them the maximum is the answer.
time and space - O(H)
*/
1) Node* search(Node *root,int &data){      [SEARCH]
        if(root==NULL || root->data == data){    //base case
            return root;        //recursively return the value till the end be it a NULL or Node. : if node then found else not found.
        }
        if(root->data > data){
            return search(root->left,data);
        }
        return search(root->right,data);
    }

2) Node* inserts(Node* root,int &data){      [INSERT]
        if(root==NULL){
            Node *newnode = new Node(data);    //new slot is found where it can be inserted
            return newnode;
        }
        if(root->data > data){
            root->left = inserts(root->left,data);
        }
        else if(root->data < data){
            root->right = inserts(root->right,data);
        }
        return root;    //to backtrack the updated node which has a new left or right child attached till the root.
    }

3) void dfs(Node* root,int &key,int &ceil){
    if(root==NULL){
        return;
    }
    if(root->data >= key){
        ceil = min(ceil,root->data);
        dfs(root->left,key,ceil);
        }
    dfs(root->right,key,ceil);
    return;
}
int findCeil(Node* root, int input) {
    if (root == NULL) return -1;
    int ceil = INT_MAX;
    dfs(root,input,ceil);
    if(ceil == INT_MAX){
        return -1;
    }
    else{
        return ceil;
    }
    
}
4) void dfs(Node *root,int &key,int &flor){
        if(root==NULL){
            return;
        }
        if(root->data > key){
            dfs(root->left,key,flor);
        }
        if(root->data <= key){
            flor = max(flor,root->data);
            dfs(root->right,key,flor);
        }
        return;
    }

    int floor(Node* root, int x) {
        if(root==NULL){
            return -1;
        }
        int flor = INT_MIN;
        dfs(root,x,flor);
        if(flor==INT_MIN){
            return -1;
        }
        else{
            return flor;
        }
    }
