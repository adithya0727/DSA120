/* Approach:  PATTERN : [VERTICAL TRAVERSAL]
Printing different views of a Binary Tree : INTUITION => VISUALISE LOOKING AT THE TREE FROM VARIOUS GIVEN POSITIONS FOR CLARITY.
Concept : Horizontal Distance => the distance from the root of a tree , ie. like drawing those vertical lines on a tree.
ROOT is considered as 0 , as we move left hd-1 and right would be hd+1.
1) Top View : So to get the horizontal view : we only have to print the FIRST/topmost Node->data for each horizontal distance , we move from left to right.
Similar pattern : use queue to store hd and node : map => KEY - hd and value (we only need one,first one) : if map is empty() , it shows that we are in a new hd and thus
insert the first node , if already exist nvm , as we got the top node for that horizontal distance.
time - O(N)*logN space - O(N) 
2) Bottom View : Same approach as previous : here we use vector<int> in map to store all map values since we want the Bottom most node->val for each horizontal Distance.
and then finally while storing in vector we push_back the back() =>last values of each vector for each hd.
time - O(N)*logN space - O(N) 
3) 
*/

1) vector<int> topView(Node *root)
    {
        vector<int>v;
        if(root==NULL){
            return v;
        }
        queue<pair<int,Node*>>q;
        map<int,int>m;
        q.push({0,root});
        while(!q.empty()){
            auto p = q.front();
            q.pop();
            Node *temp = p.second;
            int hd = p.first;
            if(m.find(hd) == m.end()){
                m[hd] = temp->data;
            }
            if(temp->left){
                q.push({hd-1,temp->left});
            }
            if(temp->right){
                q.push({hd+1,temp->right});
            }
        }
        for(auto &var : m){
            v.push_back(var.second);
        }
        return v;
    }


2) vector <int> bottomView(Node *root) {
        vector<int>v;
        if(root==NULL){
            return v;
        }
        queue<pair<int,Node*>>q;
        map<int,vector<int>>m;
        q.push({0,root});
        while(!q.empty()){
            auto p = q.front();
            q.pop();
            Node *temp = p.second;
            int hd = p.first;
            m[hd].push_back(temp->data);
            if(temp->left){
                q.push({hd-1,temp->left});
            }
            if(temp->right){
                q.push({hd+1,temp->right});
            }
        }
        for(auto &var : m){
            v.push_back(var.second.back());
        }
        return v;
    }

3) 
