/* Approach:
              1
            /   \
          2      3
        /  \
      4     5
Lets know recursive approach : left - mid - right is the order to print (4,2,5,1,3). 
algo : 1) func(root->left) 2) cout<<root->val 3) func(root->right) . Now lets relate it to iterative.
1) In-order : Using Stack : we start with moving towards the left subtree till it reaches null. (like step 1)
then we print root->val (like step 2) and then we move to the right element and start checking for left first , print and right again and the process repeats itself.
Pattern is very similar : we store the elements in stack , like stack unwinding : we pop the top element and return to the previous node and again print and perform right.
It is the same as recursion literally. time and space : O(N).

2) Pre-order : 

*/

1) //Iterative function for inorder tree traversal
void inOrder(struct Node* root)
{
    stack<Node*> s;
    Node* curr = root;
 
    while (curr != NULL || s.empty() == false) {
         
        // Reach the left most Node of the
        // curr Node
        while (curr != NULL) {
             
            // Place pointer to a tree node on
            // the stack before traversing
            // the node's left subtree
            s.push(curr);
            curr = curr->left;
        }
 
        // Current must be NULL at this point
        curr = s.top();
        s.pop();
 
        cout << curr->data << " ";
 
        // we have visited the node and its
        // left subtree.  Now, it's right
        // subtree's turn
        curr = curr->right;
 
    }
}

2) 
